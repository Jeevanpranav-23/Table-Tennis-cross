export default function PingPongGame() {
  const canvasRef = useRef(null);
  const [paddleX, setPaddleX] = useState(200);
  const [ball, setBall] = useState({ x: 250, y: 250, dx: 3, dy: 3 });
  const [touchStartX, setTouchStartX] = useState(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");

    const drawPaddle = () => {
      ctx.fillStyle = "#0095DD";
      ctx.fillRect(paddleX, canvas.height - 20, 100, 10);
    };

    const drawBall = () => {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, 10, 0, Math.PI * 2);
      ctx.fillStyle = "red";
      ctx.fill();
      ctx.closePath();
    };

    const update = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawPaddle();
      drawBall();

      let newBall = { ...ball, x: ball.x + ball.dx, y: ball.y + ball.dy };

      // Ball collision with walls
      if (newBall.x < 10 || newBall.x > canvas.width - 10) newBall.dx *= -1;
      if (newBall.y < 10) newBall.dy *= -1;

      // Ball collision with paddle with better accuracy
      if (
        newBall.y + 10 >= canvas.height - 20 &&
        newBall.x >= paddleX &&
        newBall.x <= paddleX + 100
      ) {
        newBall.dy *= -1;
        newBall.y = canvas.height - 30; // Adjust position to prevent multiple hits

        // Add slight variation to ball direction based on hit position
        let hitPosition = (newBall.x - paddleX) / 100;
        newBall.dx = 6 * (hitPosition - 0.5);
      }

      // Reset ball if it falls off
      if (newBall.y > canvas.height) {
        newBall = { x: 250, y: 250, dx: 3, dy: 3 };
      }

      setBall(newBall);
    };

    const gameLoop = setInterval(update, 20);
    return () => clearInterval(gameLoop);
  }, [paddleX, ball]);

  const handleTouchMove = (event) => {
    event.preventDefault(); // Prevent scrolling
    const rect = canvasRef.current.getBoundingClientRect();
    const touchX = event.touches[0].clientX - rect.left;
    setPaddleX(Math.max(0, Math.min(touchX - 50, canvasRef.current.width - 100)));
  };

  return (
    <div>
      <canvas
        ref={canvasRef}
        width={500}
        height={500}
        style={{ background: "#eee", touchAction: "none" }}
        onTouchMove={handleTouchMove}
      ></canvas>
    </div>
  );
}
